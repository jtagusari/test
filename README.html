<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
      ? 'dark'
      : 'default'
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
  </script>
<p><a href="/README-ja.md">日本語版 README </a></p>
<h1 id="h-risk-with-noisemodelling">H-RISK with NoiseModelling</h1>
<h2 id="about">About</h2>
<p>This is a QGIS plugin, which implements NoiseModelling (https://github.com/Universite-Gustave-Eiffel/NoiseModelling) and help estimate the health risks posed by (road traffic) noise.</p>
<h2 id="features">Features</h2>
<p>This plugin can</p>
<ul>
<li>fetch geometries from OpenStreetMap, Shuttle Radar Topography Mission, and Vector Tiles (provided by the Geospatial Information Authority of Japan).</li>
<li>predict sound levels using NoiseModelling, by executing the Java script (specified Java implementation is required).</li>
<li>estimate health risks based on the predicted sound levels and expore-response relationships shown in the Environmental Noise Guidelines in European Region (WHO Regional Office for Europe).</li>
</ul>
<p>At this moment, the operation of the plugin with NoiseModelling v4.0.2 is confirmed. (Not with v4.0.4)</p>
<h2 id="license">License</h2>
<p>This plug-in complies with the GPL v3 license.
Please see the LICENSE file for details.</p>
<p>License of the external program used by this plug-in:</p>
<ul>
<li>NoiseModelling: GPL v3</li>
<li>OpenJDK: GPL v2 (Classpath Exception)</li>
</ul>
<p>Note: This service uses the API function of the e-Stat (e-Stat), but the content of the service is not guaranteed by the government.</p>
<h2 id="how-to-install">How to install</h2>
<p>Install QGIS (version &gt;= 3.22.0) and install the plugin according to the following instruction.
Note that to calculate the sound levels, NoiseModelling (https://noise-planet.org/noisemodelling.html) and Java implementation are needed.</p>
<p>The installer (<code>installer/hrisk-setup.exe</code>) will help install required components including the present plugin.</p>
<h3 id="using-installer-windows-10">Using installer (Windows 10)</h3>
<p>Execute the installer (<code>installer/hrisk-setup.exe</code>).
The program can also install this plugin, as well as all the required components.
Environmental variables that are needed to execute NoiseModelling are also set.</p>
<h3 id="manual-install">Manual install</h3>
<h4 id="this-plugin">This plugin</h4>
<p>Install from QGIS repo or download all the files in the repository (https://gitlab.com/jtagusari/hrisk-noisemodelling) and save them in the QGIS plugin folder.</p>
<h4 id="noisemodelling">NoiseModelling</h4>
<ol>
<li>Download No-GUI version of NoiseModelling (see https://github.com/Universite-Gustave-Eiffel/NoiseModelling/releases)</li>
<li>Save all the files in your PC (e.g. <code>C:\Program Files\NoiseModelling</code>)</li>
<li>Set environmental variable of <code>NOISEMODELLING_HOME</code> to the installed folder</li>
</ol>
<h4 id="java">Java</h4>
<ol>
<li>Check the requirements of NoiseModelling and obtain the required version of Java implementation</li>
<li>Save all the files in your PC (e.g. <code>C:\Program Files\Java</code>)</li>
<li>Set environmental variable of <code>JAVA_FOR_NOISEMODELLING</code> to the installed folder. Note that <code>%JAVA_FOR_NOISEMODELLING%\bin\java.exe</code> exists.</li>
</ol>
<h2 id="tutorial-test-the-plugin">Tutorial (Test the plugin)</h2>
<p>The following is a tutorial of this plugin.
The results are in <code>tutorial</code> directory.</p>
<h3 id="fetch-the-geometries">Fetch the geometries</h3>
<p>Execute <code>Road centerline (OSM)</code> algorithm (in <code>Fetch geometries</code> group), with following parameters (unspecified parameters are default values):</p>
<ul>
<li><code>FETCH_EXTENT</code>: 141.300,141.305,43.125,43.130 [EPSG:4326]</li>
<li><code>TARGET_CRS</code>: EPSG: 32654</li>
<li><code>BUFFER</code>: 200.0 (m)</li>
</ul>
<p>Execute <code>Building (OSM)</code> algorithm with following parameters:</p>
<ul>
<li><code>FETCH_EXTENT</code>: 141.300,141.305,43.125,43.130 [EPSG:4326]</li>
<li><code>TARGET_CRS</code>: EPSG: 32654</li>
<li><code>BUFFER</code>: 200.0 (m)</li>
</ul>
<p>Execute <code>Elevation points (SRTM)</code> algorithm with following parameters. Note that user id and password of Earthdata Login (https://urs.earthdata.nasa.gov/users/new) is needed before the execution.</p>
<ul>
<li><code>FETCH_EXTENT</code>: 141.300,141.305,43.125,43.130 [EPSG:4326]</li>
<li><code>TARGET_CRS</code>: EPSG: 32654</li>
<li><code>BUFFER</code>: 200.0 (m)</li>
<li><code>USERNAME</code>: (registered user name)</li>
<li><code>PASSWORD</code>: (registered password)</li>
</ul>
<p>Note that the roads and buildings are also obtained with following procedures.</p>
<ol>
<li>get the fetch extent as a rectangle</li>
<li><code>native:extenttolayer</code> using the above <code>FETCH_EXTENT</code> as <code>INPUT</code></li>
<li><code>native:reprojectlayer</code> using the output of the previous procedure as <code>INPUT</code> and the above <code>TARGET_CRS</code> as <code>TARGET_CRS</code></li>
<li><code>native:buffer</code> using the output of the previous procedure as <code>INPUT</code> and the above <code>BUFFER</code> as <code>DISTANCE</code></li>
<li>get the features from OpenStreetMap</li>
<li><code>quickosm:downloadosmdataextentquery</code> using highway as <code>KEY</code> (if for buildings, building as <code>KEY</code>) and the extent of the obtained rectangle as the <code>EXTENT</code></li>
<li><code>native:reprojectlayer</code> using the output of the previous procedure as <code>INPUT</code> and the above <code>TARGET_CRS</code> as <code>TARGET_CRS</code></li>
<li><code>native:dissolve</code> using the output of the previous procedure as <code>INPUT</code> and the all the fields as <code>FIELD</code></li>
<li><code>native:multiparttosingleparts</code> using the output of the previous procedure as <code>INPUT</code></li>
<li>set required fields</li>
<li>add required fields to the road layer (<code>PK</code>,<code>LV_d</code>, <code>LV_e</code>, <code>LV_n</code>, <code>MV_d</code>, <code>MV_e</code>, <code>MV_n</code>, <code>HV_d</code>, <code>HV_e</code>, <code>HV_n</code>, <code>LV_spd_d</code>, <code>LV_spd_e</code>, <code>LV_spd_n</code>, <code>MV_spd_d</code>, <code>MV_spd_e</code>, <code>MV_spd_n</code>, <code>HV_spd_d</code>, <code>HV_spd_e</code>, <code>HV_spd_n</code>, <code>LWd63</code>, <code>LWd125</code>, <code>LWd250</code>, <code>LWd500</code>, <code>LWd1000</code>, <code>LWd2000</code>, <code>LWd4000</code>, <code>LWd8000</code>, <code>LWe63</code>, <code>LWe125</code>, <code>LWe250</code>, <code>LWe500</code>, <code>LWe1000</code>, <code>LWe2000</code>, <code>LWe4000</code>, <code>LWe8000</code>, <code>LWn63</code>, <code>LWn125</code>, <code>LWn250</code>, <code>LWn500</code>, <code>LWn1000</code>, <code>LWn2000</code>, <code>LWn4000</code>, <code>LWn8000</code>, <code>pvmt</code>, <code>temp_d</code>, <code>temp_e</code>, <code>temp_n</code>, <code>ts_stud</code>, <code>pm_stud</code>, <code>junc_dist</code>, <code>slope</code>, <code>way</code>)</li>
<li>add required fields to the building layer (<code>PK</code>,<code>height</code>)</li>
</ol>
<h3 id="set-traffic-volume">Set traffic volume</h3>
<p>For roads of which <code>osm_id</code> are <code>35099042</code> and <code>35099047</code>, set the following traffic volumes:</p>
<ul>
<li><code>LV_d</code>: 500 / <code>LV_e</code>: 200 / <code>LV_n</code> : 60</li>
<li><code>HV_d</code>: 70 / <code>HV_e</code>: 10 / <code>HV_n</code> : 10</li>
</ul>
<p>For a road of which <code>osm_id</code> is <code>133439796</code>, set the following traffic volumes:</p>
<ul>
<li><code>LV_d</code>: 130 / <code>LV_e</code>: 0 / <code>LV_n</code> : 0</li>
<li><code>HV_d</code>: 5 / <code>HV_e</code>: 0 / <code>HV_n</code> : 0</li>
</ul>
<h3 id="set-receivers">Set receivers</h3>
<p>Execute <code>Building facade</code> algorithm in <code>Set receiver</code> group, with the following parameters:</p>
<ul>
<li><code>BUILDING</code>: (fetched features representing the buildings)</li>
<li><code>SOURCE</code>: (fetched features representing the roads)</li>
<li><code>DELTA</code>: 2.0</li>
</ul>
<h2 id="how-to-use">How to use</h2>
<h3 id="fetch-the-geometries">Fetch the geometries</h3>
<p>The user can fetch the geometries of roads and buildings using algorithms in <code>Fetch geometries</code> group.
In Japan, precised data (including population) can be obtained using algorithms in <code>Fetch geometries (Ja)</code> group.</p>
<p>The algorithms are:</p>
<ul>
<li><code>Fetch geometries</code> group
<ul>
<li>Road centerline (OSM) (<code>fetchosmroad.py</code>): fetch road geometries from OpenStreetMap. <code>QuickOSM</code> is needed.</li>
<li>Building (OSM) (<code>fetchosmbuilding.py</code>): fetch building geometries from OpenStreetMap. <code>QuickOSM</code> is needed.</li>
<li>Elevation points (SRTM) (<code>fetchsrtmdem.py</code>): fetch elevation-points geometries from Shuttle Radar Topography Mission dataset. User id and password of Earthdata Login (https://urs.earthdata.nasa.gov/users/new) is needed.</li>
</ul>
</li>
<li><code>Fetch geometries (Ja)</code> group
<ul>
<li>Road centerline (Ja) (<code>fetchjaroad.py</code>): fetch road geometries from vector-tile map provided by the GSI of Japan</li>
<li>Buildings (Ja) (<code>fetchjabuilding.py</code>): fetch building geometries from vector-tile map provided by the GSI of Japan</li>
<li>Elevation points (Ja) (<code>fetchjadem.py</code>): fetch elevation-points geometries from vector-tile map provided by the GSI of Japan</li>
<li>Population (Ja) (<code>fetchjapop.py</code>): fetch 250m-mesh population from the ESTAT-API of Japan</li>
<li>Fetch geometries (Ja) (<code>fetchjageom.py</code>): fetch all geometries listed above (and also set receivers, if specified)</li>
</ul>
</li>
</ul>
<p>Note that <code>QuickOSM</code> plugin (https://docs.3liz.org/QuickOSM/) is needed to fetch geometries from OpenStreetMap.
To fetch geometries from Shuttle Radar Topography Mission, user id and password of Earthdata Login (https://urs.earthdata.nasa.gov/users/new) is needed.</p>
<h3 id="set-information-on-the-sound-sources">Set information on the sound sources</h3>
<p>Before calculating sound levels, the user must set traffic volumes (light/medium/heavy vehicles during day/evening/night) or the sound power levels, as the fields of road layer.
Required fields are already set in the layer fetched if the features are fetched using the algorithms in <code>Fetch geometries</code> group (previous procedure).
Or, the user can manually set the fields using algorithms in <code>Initialize features</code> group.</p>
<p>The algorithms in <code>Initialize features</code> group are:</p>
<ul>
<li>Road with acoustic information (<code>initroad.py</code>): initialize linestrings as roads</li>
<li>Road emission calculated from traffic (<code>initroademissionfromtraffic.py</code>): calculate the emission level (sound power level) using the traffic volume</li>
<li>Building (<code>initbuilding.py</code>): initialize polygons as buildings</li>
<li>Elevation point (<code>initelevationpoint.py</code>): initialize points as elevation points</li>
<li>Ground absorption (<code>initgroundabsorption.py</code>): initialize polygons as ground absorption</li>
</ul>
<h3 id="set-receiver-points">Set receiver points</h3>
<p>To set receiver points, algorithms in <code>Set receivers</code> group are available.
The algorithms, employing <code>NoiseModelling</code> algorithms, set receiver points, such as at the facades of the buildings and at delaunay grid points.</p>
<p>The algorithms in <code>Set receiver</code> group are:</p>
<ul>
<li>At building facade (<code>receiverfacade.py</code>): create receivers at building facades</li>
<li>Delaunay grid (<code>receiverdelaunaygrid.py</code>): create receivers at delaunay grid points</li>
<li>Regular grid (<code>receiverregulargrid.py</code>): create receivers at regular grid points</li>
</ul>
<h3 id="calculate-the-sound-levels">Calculate the sound levels</h3>
<p>The sound levels at receiver points can be calculate using algorithms stored in <code>Predict sound level</code> group, employing <code>NoiseModelling</code>.</p>
<p>The algorithms in <code>Predict sound level</code> group are:</p>
<ul>
<li>Prediction from traffic (<code>noisefromtraffic.py</code>): calculate the sound levels from traffic volume</li>
<li>Prediction from emission (<code>noisefromemission.py</code>): calculate the sound levels from the sound power level</li>
</ul>
<h3 id="estimate-health-risks">Estimate health risks</h3>
<p>The user can assign the number of residents of each building and estimate health risks posed by the noise, using algorithms in <code>Evaluate health risk</code> group.</p>
<p>The algorithms in <code>Evaluate health risk</code> group are:</p>
<ul>
<li>Estimate populations of buildings using Raster (<code>estimatepopulationofbuilding.py</code>): estimate the number of residents for each building using a raster representing the population</li>
<li>Estimate populations of buildings using Polygon (<code>estimatepopulationofbuildingplg.py</code>): estimate the number of residents for each building using polygons representing the population</li>
<li>Estimate level of buildings (<code>estimatelevelofbuilding.py</code>): estimate the sound level for each building</li>
<li>Estimate health risks of buildings (<code>estimateriskofbuilding.py</code>): estimate the health risks for each building</li>
</ul>
<h3 id="for-developers">For developers</h3>
<p>There are several scripts for developers, as follows:</p>
<ul>
<li><code>algabstract</code>: an abstract class inheriting <code>QgsProcessingAlgorithm</code>, defining attributes and methods
<ul>
<li>attributes
<ul>
<li><code>PARAMETERS</code>: to set UIs.</li>
<li><code>NOISEMODELLING</code>: to use NoiseModelling, such as paths and arguments.</li>
</ul>
</li>
<li>methods
<ul>
<li><code>initParameters(self) -&gt; None</code>: convert <code>PARAMETERS</code> attributes to UIs.</li>
<li><code>initNoiseModellingPath(self, paths:dict) -&gt; None</code>: set NoiseModelling paths.</li>
<li><code>initNoiseModellingArg(self, parameters:dict, context: QgsProcessingContext, feedback:QgsProcessingFeedback) -&gt; None</code>: initialize NoiseModelling arguments from UIs.</li>
<li><code>addNoiseModellingArg(self, args:dict) -&gt; None</code>: add NoiseModelling arguments.</li>
<li><code>saveVectorLayer(self, vector_layer: QgsVectorLayer, path: str) -&gt; None)</code>: save a vector layer.</li>
<li><code>saveRasterLayer(self, raster_layer: QgsVectorLayer, path: str) -&gt; None)</code>: save a raster layer.</li>
<li><code>execNoiseModellingCmd(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: exec NoiseModelling.</li>
<li><code>streamNoiseModellingCmd(self, cmd: str, feedback: QgsProcessingFeedback) -&gt; None</code>: stream NoiseModelling</li>
<li><code>importNoiseModellingResultsAsSink(self, parameters: dict, context: QgsProcessingContext, attribute: str, path: str) -&gt; None</code>: import NoiseModelling results as a sink</li>
</ul>
</li>
</ul>
</li>
<li><code>fetchabstract</code>: an abstract class inheriting <code>algabstract</code>, defining attributes and methods
<ul>
<li>attributes
<ul>
<li><code>FETCH_AREA</code>: the fetch area (<code>QgsReferencedRectangle</code>)</li>
<li><code>TILEMAP_ARGS</code>: arguments for tile-map</li>
<li><code>OSM_ARGS</code>: arguments for OpenStreetMap</li>
<li><code>WEBFETCH_ARGS</code>: arguments for fetching geometries from web without tile-map or OpenStreetMap</li>
</ul>
</li>
<li>methods
<ul>
<li><code>initUsingCanvas(self) -&gt; None</code>: set <code>FETCH_EXTENT</code> and <code>TARGET_CRS</code> to the current canvas settings</li>
<li><code>getUtmCrs(self, lng: float, lat: float) -&gt; QgsCoordinateReferenceSystem</code>: get Universal Transverse Melcator CRS</li>
<li><code>setFetchArea(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback, new_crs: QgsCoordinateReferenceSystem = None) -&gt; None</code>: set the <code>FETCH_AREA</code> attribute</li>
<li><code>fetchAreaAsVectorLayer(self) -&gt; QgsVectorLayer</code> get a vector layer from the <code>FETCH_AREA</code> attribute</li>
<li><code>setTileMapArgs(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback, geom_type: str = None) -&gt; None</code>: set the arguments for tile maps.</li>
<li><code>setOsmArgs(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback, geom_type: str=None) -&gt; None</code>: set the arguments for OpenStreetMap.</li>
<li><code>setWebFetchArgs(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: set the arguments for fetching geometries from web (but not tile maps or OpenStreetMap)</li>
<li><code>fetchFeaturesFromTile(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: fetch features from tile maps</li>
<li><code>fetchFeaturesFromOsm(self, parameters:dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: fetch features from OpenStreetMap</li>
<li><code>fetchFeaturesFromWeb(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: fetch features from web (but not tile maps or OpenStreetMap). Note that the fetched features are stored just as files</li>
<li><code>modifyFeaturesFromTile(self, fts: QgsVectorLayer | QgsRasterLayer, z: int, tx: int, ty: int)- &gt; QgsVectorLayer | QgsRasterLayer</code>: modify features fetched from tile maps</li>
<li><code>dissolveFeatures(self, fts: QgsVectorLayer) -&gt; QgsVectorLayer</code>: dissolve features</li>
<li><code>transformToTargetCrs(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback, fts: QgsVectorLayer) -&gt; QgsVectorLayer</code>: transform features (to the <code>TARGET_CRS</code>)</li>
</ul>
</li>
</ul>
</li>
<li><code>initabstract</code>: an abstract class inheriting <code>algabstract</code>, defining attributes and methods
<ul>
<li>attributes
<ul>
<li><code>FIELDS_ADD</code>: the fields to be initialized</li>
<li><code>FIELDS_INIT</code>: the existing fields and <code>FIELDS_ADD</code></li>
<li><code>FIELDS_FROM</code>: whether each field existed or in <code>FIELDS_ADD</code></li>
</ul>
</li>
<li>methods
<ul>
<li><code>setFields(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; None</code>: set <code>FIELDS_INIT</code> and <code>FIELDS_FROM</code></li>
<li><code>createVectorLayerAsSink(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback) -&gt; str</code>: create a sink using the fields and return <code>dest_id</code></li>
</ul>
</li>
</ul>
</li>
<li><code>noiseabstract</code>: an abstract class inheriting <code>algabstract</code>, defining attributes and methods
<ul>
<li>attributes
<ul>
<li><code>BLDG_LEVEL_ARGS</code>: arguments to assign the sound level to each building</li>
<li><code>ISOSURFACE_ARGS</code>: arguments to create isosurface</li>
<li><code>PROC_RESULTS</code>: results of the calculation</li>
</ul>
</li>
<li>methods
<ul>
<li><code>outputWpsArgs(self, parameters:dict, context:QgsProcessingContext, extent_rec: QgsReferencedRectangle) -&gt; str</code>: output a polygon (sink and output the <code>dest_id</code>) that stores arguments of the calculation</li>
<li><code>cmptBuildingLevel(self, parameters: dict, context: QgsProcessingContext, feedback: QgsProcessingFeedback, bldg_layer: QgsVectorLayer, rcv_layer: QgsVectorLayer) -&gt; None</code>: create sound-level-assigned buildings</li>
</ul>
</li>
</ul>
</li>
<li><code>worldmesh.py</code>: used for obtaining the world mesh code (from Research Institute for World Grid Squares)</li>
</ul>
<h2 id="how-to-uninstall">How to uninstall</h2>
<p>Delete the files and folders in <code>JAVA_FOR_NOISEMODELLING</code> and <code>NOISEMODELLING_HOME</code> paths and delete the environmental variables.</p>

</body>
</html>
